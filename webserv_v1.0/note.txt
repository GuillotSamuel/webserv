-le hostname n'existe pas.

-on peut ecouter a 80 ou a 127.0.0.1:80

-on peut ecouter sur plusieurs adresse differente avec le meme port 
ou garder la meme adresse avec changement de port
ex :
listen 127.0.0.3:80
listen 127.0.0.2:80
listen 127.0.0.1:80
listen 127.0.0.1:81
listen 127.0.0.1:82

-on ne PEUT PAS avoir deux server avec la meme adresse et le meme port
ex :
server{
	listen 127.0.0.3:80
}
server{
	listen 127.0.0.3:80
}
!!!!! not allowed

-si aucune adress est specifie, alors on va pouvoir ecouter a toute
les adresses possible.

idee : 
-verifier si adress ip > 255 ou < 0. 
-verifier si sur plusieurs block serveur meme address.
-


-------------------------------------------------------------------



-exemple pour une requete
-reception de la requete client avec l'algo epoll

-traitement initial de la requete 
	-analyse de la requete
	-recherche du bloc server et location
-application des directives de configuration
	-redirection (301 302)
	-acces aux fichiers statique (html, css, etc)
	-execution CGI 
-generation de la reponse
	-ajout des entete approprie
-envoie de la reponse
	-retour a l'algo epoll


REDIRECTION : 
server {
    listen 80;
    server_name example.com;
    return 301 https://example.com$request_uri;  # Redirection HTTP vers HTTPS
}

Ici, on doit redirige automatiquement toute requête HTTP vers la version
HTTPS du site.

-301 (Moved Permanently) : 
Redirection permanente qui indique que l'URL a changé de manière définitive.
Les moteurs de recherche mettent à jour leurs index pour refléter ce changement.

-302 (Found / Moved Temporarily)
Redirection temporaire, utilise lorsque le changement d'URL est temporaire
et que l'URL d'origin pourrait etre reutilisee.


FICHIER STATIQUE : 
-Verifie si le fichier existe
-Genere en tete + contenu

CGI : 
ex : config
server {
    listen 80;
    server_name example.com;
    root /var/www/html;
    location /cgi-bin/ {
        fastcgi_pass 127.0.0.1:9000;
        fastcgi_param SCRIPT_FILENAME /usr/lib/cgi-bin/$fastcgi_script_name;
        include fastcgi_params;
    }
	location / {
		
	}


il faut le nom du script dans le fichier de config.


Chercher le bloc location 

1 - correspondance exactes:

	-ex : si on recoit l'URI "/"
	location = / {

	}
	-ex : si on recoit l'URI "index.html"
	location = index.html {

	}

2 - correspondance par prefixe

	-ex : si on recoit l'URI "/images/bla.jpg"
	location /images/ {

	}
	-ex : si on recoit l'URI "/images/blo.jpg"
	location /images/bla/ {

	}
	Note importante : si plusieurs blocs location correspondent à un URI,
	Nginx sélectionne celui avec la correspondance la plus longue.

3 - correspondance avec expression reguliere // NOT TO DO

	-ex : ~ sensible a la casse.
	location ~ .php {
		# directives pour traiter les fichiers PHP
	}
	-ex : ~* insensible a la casse.
	location ~* .(gif|jpg|jpeg) {
    # directives pour tous les fichiers d'images .gif, .jpg, .jpeg,
	.GIF .JpG
		insensibles à la casse
	}

4 - correspondance implicite avec des fichiers statiques

	Si aucun bloc ne correspond avant
	-ex : 

	location / {
    	try_files $uri $uri/ =404;
	}
	on va regarder si l'uri correspond directement, dans quel cas on va directement servir
	la reponse au lieu de passer par la recherche d'autre correspondance 

	Directive spéciale : location ^~


Il existe une directive spéciale qui peut être utilisée dans les blocs location pour
prioriser une correspondance de préfixe et empêcher Nginx de tester les expressions
régulières. Cela est utile lorsque vous avez une correspondance de préfixe que vous ne
voulez pas voir supplantée par des expressions régulières.

    Exemple d'utilisation de ^~ :

	location ^~ /images/ {
		# directives pour toutes les requêtes commençant par /images/
	}
	location ~* \.(jpg|jpeg|png)$ {
		# directives pour toutes les images
	}

Ici, toute requête commençant par /images/ sera traitée par le premier bloc,
même si le fichier demandé est une image (qui correspondrait aussi à
l'expression régulière).